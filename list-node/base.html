<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>链表 | 算法学习</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/algorithm-learn/assets/css/0.styles.79878703.css" as="style"><link rel="preload" href="/algorithm-learn/assets/js/app.6a9ae5b4.js" as="script"><link rel="preload" href="/algorithm-learn/assets/js/2.be16b8d1.js" as="script"><link rel="preload" href="/algorithm-learn/assets/js/10.4601b49a.js" as="script"><link rel="prefetch" href="/algorithm-learn/assets/js/11.0fef6238.js"><link rel="prefetch" href="/algorithm-learn/assets/js/12.15b540d1.js"><link rel="prefetch" href="/algorithm-learn/assets/js/13.04adfdde.js"><link rel="prefetch" href="/algorithm-learn/assets/js/14.4f63f145.js"><link rel="prefetch" href="/algorithm-learn/assets/js/15.97e7b96c.js"><link rel="prefetch" href="/algorithm-learn/assets/js/16.81f788fb.js"><link rel="prefetch" href="/algorithm-learn/assets/js/3.8ee437fd.js"><link rel="prefetch" href="/algorithm-learn/assets/js/4.2d3b0349.js"><link rel="prefetch" href="/algorithm-learn/assets/js/5.8ea8b43f.js"><link rel="prefetch" href="/algorithm-learn/assets/js/6.c43cdb0d.js"><link rel="prefetch" href="/algorithm-learn/assets/js/7.c67f01b2.js"><link rel="prefetch" href="/algorithm-learn/assets/js/8.32364bcd.js"><link rel="prefetch" href="/algorithm-learn/assets/js/9.a07c06cf.js">
    <link rel="stylesheet" href="/algorithm-learn/assets/css/0.styles.79878703.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/algorithm-learn/" class="home-link router-link-active"><!----> <span class="site-name">算法学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/algorithm-learn/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/strugglinglee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.strugglinglee.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/algorithm-learn/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="了解更多" class="dropdown-title"><span class="title">了解更多</span> <span class="arrow down"></span></button> <button type="button" aria-label="了解更多" class="mobile-dropdown-title"><span class="title">了解更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/strugglinglee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://blog.strugglinglee.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/algorithm-learn/数据结构.html" class="sidebar-link">数据结构</a></li><li><a href="/algorithm-learn/数组的应用.html" class="sidebar-link">数组的应用</a></li><li><a href="/algorithm-learn/字符串应用.html" class="sidebar-link">字符串应用</a></li><li><a href="/algorithm-learn/hash表.html" class="sidebar-link">hash表</a></li><li><a href="/algorithm-learn/list-node/base.html" aria-current="page" class="active sidebar-link">链表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm-learn/list-node/base.html#题目分类" class="sidebar-link">题目分类</a></li><li class="sidebar-sub-header"><a href="/algorithm-learn/list-node/base.html#链表的处理" class="sidebar-link">链表的处理</a></li><li class="sidebar-sub-header"><a href="/algorithm-learn/list-node/base.html#链表的反转及其衍生题目" class="sidebar-link">链表的反转及其衍生题目</a></li><li class="sidebar-sub-header"><a href="/algorithm-learn/list-node/base.html#链表成环问题及其衍生题目" class="sidebar-link">链表成环问题及其衍生题目</a></li></ul></li><li><a href="/algorithm-learn/时间复杂度和空间复杂度.html" class="sidebar-link">时间复杂度和空间复杂度</a></li><li><a href="/algorithm-learn/递归/base.html" class="sidebar-link">递归</a></li><li><a href="/algorithm-learn/二分法/base.html" class="sidebar-link">二分法</a></li><li><a href="/algorithm-learn/BFS/BFS.html" class="sidebar-link">广度优先搜索</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h1> <h2 id="题目分类"><a href="#题目分类" class="header-anchor">#</a> 题目分类</h2> <ol><li>链表的处理: 合并、<strong>删除(重点)</strong></li> <li>链表的反转及其衍生题目</li> <li>链表成环问题及其衍生题目</li></ol> <h2 id="链表的处理"><a href="#链表的处理" class="header-anchor">#</a> 链表的处理</h2> <h3 id="合并"><a href="#合并" class="header-anchor">#</a> 合并</h3> <h4 id="真题应用"><a href="#真题应用" class="header-anchor">#</a> 真题应用</h4> <blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的
输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4。</p></blockquote> <h4 id="解题思路"><a href="#解题思路" class="header-anchor">#</a> 解题思路</h4> <ol><li><strong>中心思想</strong>——处理链表的本质，是处理<strong>链表结点</strong>之间的指针关系。</li> <li>合并为一个链表，我们恰当地补齐双方之间结点 next 指针的指向关系，就能达到目的</li> <li>类似穿针引线，现在线有了，缺的是一根针</li> <li>针每次钻进扣子眼儿之前，要先比较一下它眼前的两个扣子，选择其中值较小的那个，优先把它串进去。一次串一个，直到所有的扣子都被串进一条线为止</li> <li>还要考虑两个链表长度不等的情况：若其中一个链表已经完全被串进新链表里了，而另一个链表还有剩余结点，考虑到该链表本身就是有序的，我们可以直接把它整个拼到目标链表的尾部。</li></ol> <h4 id="题解"><a href="#题解" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">mergeTwoLists</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">l1<span class="token punctuation">,</span> l2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义头结点，确保链表可以被访问到</span>
  <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// cur 这里就是咱们那根“针”</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>

  <span class="token comment">// “针”开始在 l1 和 l2 间穿梭了</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 l1 的结点值较小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">&lt;=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 先串起 l1 的结点</span>
      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
      <span class="token comment">// l1 指针向前一步</span>
      l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// l2 较小时，串起 l2 结点</span>
      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
      <span class="token comment">// l2 向前一步</span>
      l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// “针”在串起一个结点后，也会往前一步</span>
    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 处理链表不等长的情况</span>
  cur<span class="token punctuation">.</span>next <span class="token operator">=</span> l1 <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>
  <span class="token comment">// 返回起始结点</span>
  <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="题解笔记"><a href="#题解笔记" class="header-anchor">#</a> 题解笔记</h4> <ol><li>head 作为线，cur 作为针</li> <li>cur.next 的改动 会因为引用关系 改变 head 的 next</li> <li>cur = cur.next 向前移动一步的过程 可以一步一步改变 head 的 next</li> <li>处理链表不等长的情况</li></ol> <h3 id="删除"><a href="#删除" class="header-anchor">#</a> 删除</h3> <h4 id="真题应用-2"><a href="#真题应用-2" class="header-anchor">#</a> 真题应用</h4> <blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
输入: 1-&gt;1-&gt;2
输出: 1-&gt;2
示例 2:
输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3</p></blockquote> <h4 id="解题思路-2"><a href="#解题思路-2" class="header-anchor">#</a> 解题思路</h4> <ol><li>需要删除的目标结点的前驱结点 next 指针往后指一格</li></ol> <h4 id="题解-2"><a href="#题解-2" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">deleteDuplicates</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 设定 cur 指针，初始位置为链表第一个结点</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token comment">// 遍历链表</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 若当前结点和它后面一个结点值相等（重复）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val <span class="token operator">===</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 删除靠后的那个结点（去重）</span>
      cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 若不重复，继续遍历</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="题解笔记-2"><a href="#题解笔记-2" class="header-anchor">#</a> 题解笔记</h4> <ol><li>while 循环判断条件：当前节点和下个节点不为空 不然继续判断也没意义</li> <li>当前节点和下个节点值比较：cur.val === cur.next.val</li> <li>继续往下遍历的方法：cur = cur.next</li></ol> <h3 id="删除问题的延伸-dummy-结点登场"><a href="#删除问题的延伸-dummy-结点登场" class="header-anchor">#</a> 删除问题的延伸——dummy 结点登场</h3> <h4 id="真题应用-3"><a href="#真题应用-3" class="header-anchor">#</a> 真题应用</h4> <blockquote><p>给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。
输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出: 1-&gt;2-&gt;5
示例 2:
输入: 1-&gt;1-&gt;1-&gt;2-&gt;3
输出: 2-&gt;3</p></blockquote> <h4 id="解题思路-3"><a href="#解题思路-3" class="header-anchor">#</a> 解题思路</h4> <ol><li>链表的第一个结点，没有前驱结点，可以用 dummy 结点来解决这个问题。<strong>dummy 结点</strong>是人为制造出来的第一个结点的前驱结点，这样链表中所有的结点都能确保有一个前驱结点，也就都能够用同样的逻辑来处理了。dummy 结点能够帮助我们降低链表处理过程的复杂度，处理链表时，不设 dummy 结点思路可能会打不开；设了 dummy 结点的话，就算不一定用得上，也不会出错。</li> <li>由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。</li></ol> <h4 id="题解-3"><a href="#题解-3" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">deleteDuplicates</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 极端情况：0个或1个结点，则不会重复，直接返回</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// dummy 登场</span>
  <span class="token keyword">let</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// dummy 永远指向头结点</span>
  dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token comment">// cur 从 dummy 开始遍历</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
  <span class="token comment">// 当 cur 的后面有至少两个结点时</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对 cur 后面的两个结点进行比较</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">===</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 若值重复，则记下这个值</span>
      <span class="token keyword">let</span> val <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
      <span class="token comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>val <span class="token operator">===</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 若有，则删除</span>
        cur<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 若不重复，则正常遍历</span>
      cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 返回链表的起始结点</span>
  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="链表的反转及其衍生题目"><a href="#链表的反转及其衍生题目" class="header-anchor">#</a> 链表的反转及其衍生题目</h2> <p>有一类会涉及到反复的遍历。涉及反复遍历的题目，只要用常规的思路分析它，你会发现它一定涉及反复遍历；
同时，涉及反复遍历的题目，还有一个更明显的特征，就是它们往往会涉及相对复杂的链表操作，比如<strong>反转、指定位置的删除</strong>等等。</p> <h3 id="快慢指针与多指针"><a href="#快慢指针与多指针" class="header-anchor">#</a> 快慢指针与多指针</h3> <p>双指针中的“快慢指针”。快慢指针指的是两个一前一后的指针，两个指针往同一个方向走，只是一个快一个慢。快慢指针严格来说只能有俩，不过实际做题中，可能会出现一前、一中、一后的三个指针，这种超过两个指针的解题方法也叫“多指针法”。</p> <p>快慢指针+多指针，双管齐下，可以帮助我们解决链表中的大部分复杂操作问题。</p> <h3 id="快慢指针-删除链表的倒数第-n-个结点"><a href="#快慢指针-删除链表的倒数第-n-个结点" class="header-anchor">#</a> 快慢指针——删除链表的倒数第 N 个结点</h3> <blockquote><p>给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
示例：
给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.
当删除了倒数第二个结点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote> <h4 id="dummy-结点的使用"><a href="#dummy-结点的使用" class="header-anchor">#</a> dummy 结点的使用</h4> <p><strong>dummy 结点</strong>可以帮我们处理掉头结点为空的边界问题，帮助我们简化解题过程。
因此涉及链表操作、尤其是涉及结点删除的题目（对前驱结点的存在性要求比较高）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 这里的 head 是链表原有的第一个结点</span>
dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
</code></pre></div><h4 id="倒数-变-正数"><a href="#倒数-变-正数" class="header-anchor">#</a> “倒数”变“正数”</h4> <p>“倒数第 N 个” 咱们完全可以转换为“正数第 len - n + 1&quot;个。</p> <p><strong>遍历两趟：</strong></p> <ol><li>第一趟，设置一个变量 count = 0，每遍历到一个不为空的结点，count 就加 1，一直遍历到链表结束为止，得出链表的总长度 len；</li> <li>根据这个总长度，咱们就可以算出倒数第 n 个到底是正数第几个了（M = len - n + 1），那么我们遍历到第 M - 1（也就是 len - n） 个结点的时候就可以停下来，执行删除操作。</li></ol> <p><strong>总结：</strong>
链表删除问题中，若走两次遍历，我们做了两件事： 1.求长度 2.做减法，找定位。</p> <p>**Tips:**超过一次的遍历应该主动去思考，如果一次遍历来解决这个问题，要请双指针法来帮忙了。</p> <h4 id="快慢指针"><a href="#快慢指针" class="header-anchor">#</a> 快慢指针</h4> <ol><li>两个指针 slow 和 fast，全部指向链表的起始位——dummy 结点</li> <li>快指针先出发，在第 n 个结点处打住，这里 n=2</li> <li>快慢指针一起前进，当快指针前进到最后一个结点处时，两个指针再一起停下来</li> <li>慢指针所指的位置，就是倒数第 n 个结点的前一个结点</li></ol> <p><strong>总结：</strong>
把做减法和找定位这个过程给融合了。通过快指针先行一步、接着快慢指针一起前进这个操作，巧妙地把两个指针之间的差值保持在了“n”上（用空间换时间，本质上其实就是对关键信息进行提前记忆，这里咱们相当于用两个指针对差值实现了记忆），这样当快指针走到链表末尾（第 len 个）时，慢指针刚好就在 len - n 这个地方稳稳落地。</p> <h4 id="题解-4"><a href="#题解-4" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">removeNthFromEnd</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化 dummy 结点</span>
  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// dummy指向头结点</span>
  dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token comment">// 初始化快慢指针，均指向dummy</span>
  <span class="token keyword">let</span> fast <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
  <span class="token keyword">let</span> slow <span class="token operator">=</span> dummy<span class="token punctuation">;</span>

  <span class="token comment">// 快指针闷头走 n 步</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    n<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 快慢指针一起走</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 慢指针删除自己的后继结点</span>
  slow<span class="token punctuation">.</span>next <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token comment">// 返回头结点</span>
  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="多指针法-链表的反转"><a href="#多指针法-链表的反转" class="header-anchor">#</a> 多指针法——链表的反转</h3> <h4 id="真题应用-4"><a href="#真题应用-4" class="header-anchor">#</a> 真题应用</h4> <blockquote><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote> <h4 id="解题思路-4"><a href="#解题思路-4" class="header-anchor">#</a> 解题思路</h4> <ol><li>处理链表的本质，是处理链表结点之间的指针关系</li> <li>如何去反转指针的指向，这里我们需要用到三个指针，它们分别指向<strong>目标结点（cur）</strong>、<strong>目标结点的前驱结点（pre）</strong>、<strong>目标结点的后继结点（next）</strong></li> <li>只需要一个简单的 cur.next = pre，就做到了 next 指针的反转</li></ol> <h4 id="题解-5"><a href="#题解-5" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">reverseList</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化前驱结点为 null</span>
  <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 初始化目标结点为头结点</span>
  <span class="token keyword">let</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token comment">// 只要目标结点不为 null，遍历就得继续</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 记录一下 next 结点</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment">// 反转指针</span>
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
    <span class="token comment">// pre 往前走一步</span>
    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
    <span class="token comment">// cur往前走一步</span>
    cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 反转结束后，pre 就会变成新链表的头结点</span>
  <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="局部反转一个链表"><a href="#局部反转一个链表" class="header-anchor">#</a> 局部反转一个链表</h3> <h4 id="真题应用-5"><a href="#真题应用-5" class="header-anchor">#</a> 真题应用</h4> <blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
说明：1 ≤ m ≤ n ≤ 链表长度。
示例：
输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote> <h4 id="题解-6"><a href="#题解-6" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @param {number} m
 * @param {number} n
 * @return {ListNode}
 */</span>
<span class="token comment">// 入参是头结点、m、n</span>
<span class="token keyword">const</span> <span class="token function-variable function">reverseBetween</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 定义pre、cur，用leftHead来承接整个区间的前驱结点</span>
  <span class="token keyword">let</span> pre<span class="token punctuation">,</span> cur<span class="token punctuation">,</span> leftHead<span class="token punctuation">;</span>
  <span class="token comment">// 别忘了用 dummy 嗷</span>
  <span class="token keyword">const</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// dummy后继结点是头结点</span>
  dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
  <span class="token comment">// p是一个游标，用于遍历，最初指向 dummy</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
  <span class="token comment">// p往前走 m-1 步，走到整个区间的前驱结点处</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 缓存这个前驱结点到 leftHead 里</span>
  leftHead <span class="token operator">=</span> p<span class="token punctuation">;</span>
  <span class="token comment">// start 是反转区间的第一个结点</span>
  <span class="token keyword">let</span> start <span class="token operator">=</span> leftHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token comment">// pre 指向start</span>
  pre <span class="token operator">=</span> start<span class="token punctuation">;</span>
  <span class="token comment">// cur 指向 start 的下一个结点</span>
  cur <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
  <span class="token comment">// 开始重复反转动作</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> m<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
    pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
    cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//  leftHead 的后继结点此时为反转后的区间的第一个结点</span>
  leftHead<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>
  <span class="token comment">// 将区间内反转后的最后一个结点 next 指向 cur</span>
  start<span class="token punctuation">.</span>next <span class="token operator">=</span> cur<span class="token punctuation">;</span>
  <span class="token comment">// dummy.next 永远指向链表头结点</span>
  <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="链表成环问题及其衍生题目"><a href="#链表成环问题及其衍生题目" class="header-anchor">#</a> 链表成环问题及其衍生题目</h2> <h3 id="如何判断链表是否成环"><a href="#如何判断链表是否成环" class="header-anchor">#</a> 如何判断链表是否成环？</h3> <blockquote><p>输入：[3,2,0,4]（链表结构如下图） 输出：true
解释：链表中存在一个环</p></blockquote> <h4 id="思路"><a href="#思路" class="header-anchor">#</a> 思路</h4> <p>一个环形链表的基本修养，是能够让遍历它的游标回到原点。
从 flag 出发，只要我能够再回到 flag 处，那么就意味着，我正在遍历一个环形链表。</p> <h4 id="解题"><a href="#解题" class="header-anchor">#</a> 解题</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @return {boolean}
 */</span>
<span class="token comment">// 入参是头结点</span>
<span class="token keyword">const</span> <span class="token function-variable function">hasCycle</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 只要结点存在，那么就继续遍历</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果 flag 已经立过了，那么说明环存在</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 flag 没立过，就立一个 flag 再往下走;</span>
      head<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="环形链表衍生问题-定位环的起点"><a href="#环形链表衍生问题-定位环的起点" class="header-anchor">#</a> 环形链表衍生问题——定位环的起点</h3> <blockquote><p>给定一个链表，返回链表开始入环的第一个结点。 如果链表无环，则返回 null。
示例 1:
输入：head = [3,2,0,-4] 输出：tail connects to node index 1 解释：链表中有一个环，其尾部连接到第二个结点。
示例 2:
输入：head = [1,2]
输出：tail connects to node index 0
示例 3:
输入：head = [1]
输出：no cycle
解释：链表中没有环。</p></blockquote> <h4 id="解题思路-5"><a href="#解题思路-5" class="header-anchor">#</a> 解题思路</h4> <p>因为如果一个结点是环形链表成环的起点，那么它一定是第一个被发现 flag 标志已存在的结点</p> <h4 id="题解-7"><a href="#题解-7" class="header-anchor">#</a> 题解</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
 * @param {ListNode} head
 * @return {ListNode}
 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">detectCycle</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      head<span class="token punctuation">.</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="快慢指针解题"><a href="#快慢指针解题" class="header-anchor">#</a> 快慢指针解题</h4> <p>这道题还有一个公认的比较经典的思路，就是用快慢指针来做：</p> <p>定义慢指针 slow，快指针 fast。
两者齐头并进， slow 一次走一步、fast 一次 走两步。
这样如果它们是在一个有环的链表里移动，一定有相遇的时刻。</p> <p>这个原理证明起来也比较简单：我们假设移动的次数为 t，slow 移动的路程就是t，fast 移动的路程为2t，假如环的长度为 s，那么当下面这个条件：</p> <p>2t - t = s
也就是：</p> <p>t = s
满足时，slow 和 fast 就一定会相遇。反之，如果两者没有相遇，同时 fast 遍历到了链表的末尾，发现 next 指针指向 null，则链表中不存在环。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm-learn/hash表.html" class="prev">
        hash表
      </a></span> <span class="next"><a href="/algorithm-learn/时间复杂度和空间复杂度.html">
        时间复杂度和空间复杂度
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/algorithm-learn/assets/js/app.6a9ae5b4.js" defer></script><script src="/algorithm-learn/assets/js/2.be16b8d1.js" defer></script><script src="/algorithm-learn/assets/js/10.4601b49a.js" defer></script>
  </body>
</html>
